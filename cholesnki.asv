clearvars; clc;

% Lista dei file con le matrici da testare
matFiles = {'data/cfd1.mat', 'data/cfd2.mat', 'data/ex15.mat', 'data/shallow_water1.mat', 'data/parabolic_fem.mat', 'data/G3_circuit.mat', 'data/apache2.mat'};

for k = 1:length(matFiles)
    % Caricamento selettivo
    data = load(matFiles{k}, 'Problem');
    A = data.Problem.A;

    % Pulizia zeri espliciti
    [i, j, v] = find(A);
    A = sparse(i(v ~= 0), j(v ~= 0), v(v ~= 0), size(A,1), size(A,2));

    % Dimensione matrice
    n = size(A,1);

    % Soluzione esatta
    xe = ones(n,1);
    b = A * xe;

    % Stato prima
    m1 = whos;

    % Risoluzione sistema
    tic;
    x = A \ b;
    t = toc;

    % Stato dopo
    m2 = whos;

    % Errore relativo
    err = norm(x - xe) / norm(xe);

    % Memoria in MB
    mem1 = sum([m1.bytes]);
    mem2 = sum([m2.bytes]);
    mem = (mem2 - mem1) / 1024^2;

    % Output a console
    fprintf('Matrix: %s | n = %d | Time = %.3f s | Error = %.2e | Memory = %.2f MB\n', ...
        data.Problem.name, n, t, err, mem);

    % --- Grafico per questa matrice ---
    figure;
    values = [t, err, mem];
    labels = {'Tempo (s)', 'Errore relativo', 'Memoria (MB)'};
    bar(values);
    set(gca, 'YScale', 'log');  % scala logaritmica in ordinata
    set(gca, 'XTickLabel', labels);
    ylabel('Valore (scala log)');
    title(sprintf('Prestazioni per la matrice "%s" (n = %d)', data.Problem.name, n));
    grid on;
end